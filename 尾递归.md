

> 尾递归的本质就是不需返回，直接不断向下计算，将每一步计算结果传入下一层，这样最后一层就包含了前面所有层的结果，最后一层的结果就是需要的输出。

参考：尾递归为啥能优化？ - brambles的文章 - 知乎
https://zhuanlan.zhihu.com/p/36587160

#### 示例

需求：计算n的阶乘。

* 非尾递归

```js
function fact(n) {
    if (n <= 0) {
        return 1;
    } else {
        return n * fact(n - 1);
    }
}
```

```js
6 * fact(5)
6 * (5 * fact(4))
6 * (5 * (4 * fact(3))))
6 * (5 * (4 * (3 * (2 *fact(1)))))
```

* 尾递归

```js
function fact(n, r) {
    if (n <= 0) {
        return 1 * r;
    } else {
        return fact(n - 1, r * n);
    }
}
```

```js
fact(6,1)
fact(5,1*6)
fact(4,6*5)
fact(3,30*4)
fact(2,120*3)
fact(1,360*2)
fact(0,720*1) // 1*720=720
```

1. “尾递归优化”是编译器或者解释器的工作，不是函数本身实现的。

2. 编译器或解释器为什么可以针对尾递归代码做优化？

   观察上面非尾递归的代码，函数的执行需要很多“层”。当前层函数执行过程中，需要进入下层，下层执行完毕后，需要将执行结果返回上层，以保证上层函数继续执行。而尾递归代码不需要，因为没有返回上层的必要（最后一次调用函数就已经得到了最终结果，增整个函数以及完完全全执行结束了）。




